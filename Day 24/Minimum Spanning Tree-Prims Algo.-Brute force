int spanningTreePrims ( int V , vector<int> adj[] , int source )
	{
	    //priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>>pq ;  // min heap 
	    //pq.push ( { 0 , source } ) ;
	    vector<int> key ( V , INT_MAX ) ;
	    vector<bool> MST ( V , false ) ;
	    vector<int> parent( V , -1 ) ;
	    int minSpanning = 0 ; 
	    
	    key[0] = 0 ;
	    for ( int loop = 0 ; loop < V-1 ; loop++ )
	    {
	        int min = INT_MAX , node ; 
	        for ( int i = 0 ; i < V ; i++ )
	        {
	            if ( key[i] < min and MST[i] == false )
	            {
	                min = key[i] ;
	                node = i ; 
	            }
	        }
	        MST[node] = true ; 
	        minSpanning += key[it.first] ; // sum of the min spanning tree value
	        for ( auto it : adj[node] )
	        {
	            if ( MST[it.first] == false and it.second < key[it.first] )
	            {
	                
	                key[it.first] = it.second ;
	                parent[it.first] = node ; 
	                
	            }
	        }
	    }
	    for ( int i = 1 ; i < V ; i++ )
	    	cout << parent[i] << "-->" << i << "\n" ;
	    return minSpanning ; 
	}
    int spanningTree(int V, vector<pair<int,int>> adj[])
    {
       return spanningTreePrims ( V , adj , 0 ) ;
    }
